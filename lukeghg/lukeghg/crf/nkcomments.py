import os
from xml.etree.ElementTree import ElementTree as ET
from xml.etree.ElementTree import Element,SubElement,dump
from optparse import OptionParser as OP
import glob
from lukeghg.crf.uid340to500mapping import MapUID340to500, Create340to500UIDMapping
import lukeghg.crf.ppxml as ppxml
import lukeghg.crf.crfxmlconstants as crfxmlconstants 


def SortYearList(year):
    y = year.get('name')
    return int(y)

def InsertNKComment(uid,t,nkcomments_ls,counter,not_found_uid_ls,start_year):
    """Insert notation key comments to CRFReporter xml file
       uid: the time series uid
       t: the xml tree
       nkcomments: comments for IE and NE notation keys
       IE: the three comments in the following order:
       1) Allocation by party
       2) Allocation by IPCC
       3) NK explanation
       NE: the following one comment
       1) NK explanation
    """
    it = t.iter('variable')
    variablels = [e for e in it if e.tag=='variable']
    #Find the time series that match the UID
    varls = [var for var in variablels if var.get('uid')==uid]
    if len(varls) == 0:
        print("UID:", uid, "not found, doing nothing")
        not_found_uid_ls.append(uid)
    elif len(varls)> 1:
        print("UID:", uid, "not unique, found",len(uidls),"time series, doing nothing")
    else:
        #Now start populating xml with comments
        variable=varls[0]
        #This element is a list of length two: a) the time series and b) a comment
        yearscommentls = list(variable)
        #Time series is the first one
        years = yearscommentls[0]
        #The time series is now in a list 
        yearls = list(years)
        #Sort the list
        yearls.sort(key=SortYearList)
        printed=False
        if len(nkcomments_ls) == 1:
            print(str(counter)+")","Inserting NE comment for UID:",uid)
            print("  NK explanation:",nkcomments_ls[0])
        else:
            print(str(counter)+")","Inserting IE comment for UID:",uid)
            print("  Allocation by party:",nkcomments_ls[0])
            print("  Allocation by ipcc:",nkcomments_ls[1])
            print("  NK explanation:",nkcomments_ls[2])
        #Filter out years outside KPLULUCF inventory
        if start_year == crfxmlconstants.kp_start_year:
            yearls=[x for x in yearls if int(x.get('name')) >= crfxmlconstants.kp_start_year]
        for year_record in yearls:
            recordls = list(year_record)
            #dump(year_record)
            #Take the record itsels that has the single value and the comment
            record = recordls[0]
            #dump(record)
            #Take the value and the comment
            valuecommentls = list(record)
            #Time series is the first and the comment list to be generated is the second
            comment_list = valuecommentls[1]
            #dump(commentls)
            #It seems NK Category is generated by the reporter
            #For NE only one comment
            #print(len(nkcomments_ls),uid)
            print(year_record.get('name'),end=" ",flush=True)
            if len(nkcomments_ls) == 1:
                comment0 = SubElement(comment_list,'comment')
                text0 = SubElement(comment0,'text')
                type0 = SubElement(comment0,'type')
                audience0 = SubElement(comment0,'audience')
                text0.text = nkcomments_ls[0]
                type0.text = 'NK Explanation'
                audience0.text = 'Official'
            elif len(nkcomments_ls) == 3:
                #For IE The comments are always in the following order in the comment files
                #1: Allocation by party
                comment1 = SubElement(comment_list,'comment')
                text1 = SubElement(comment1,'text')
                type1 = SubElement(comment1,'type')
                audience1 = SubElement(comment1,'audience')
                text1.text = nkcomments_ls[0]
                type1.text = 'Allocation by party'
                audience1.text = 'Official'
                #2: Allocation by IPCC
                comment2 = SubElement(comment_list,'comment')
                text2 = SubElement(comment2,'text')
                type2 = SubElement(comment2,'type')
                audience2 = SubElement(comment2,'audience')
                text2.text = nkcomments_ls[1]
                type2.text = 'Allocation by ipcc'
                audience2.text = 'Official'
                #3: NK explanation
                comment3 = SubElement(comment_list,'comment')
                text3 = SubElement(comment3,'text')
                type3 = SubElement(comment3,'type')
                audience3 = SubElement(comment3,'audience')
                text3.text = nkcomments_ls[2] 
                type3.text = 'NK Explanation'
                audience3.text = 'Official'
                #4: XML export seems to generate 4th comment (type is Comment) where the 'audience' is Party
                #   The comment itself is the same as in 'Allocation by ipcc'
                #comment4 = SubElement(comment_list,'comment')
                #text4 = SubElement(comment4,'text')
                #type4 = SubElement(comment4,'type')
                #audience4 = SubElement(comment4,'audience')
                #text4.text = nkcomments_ls[1] 
                #type4.text = 'Comment'
                #audience4.text = 'Party'
            else:
                print("The number of comments is", len(nkcomments_ls),",doing nothing")
                print("(NE has one comment and IE has three)")
            #5: It seems that in practice the only three available tabs for comments are
            #official comment, party comment and user comment. The xml for the official comment
            #seems to be as follows where all the three comments will be inserted.
            comment5 = SubElement(comment_list,'comment')
            text5 = SubElement(comment5,'text')
            type5 = SubElement(comment5,'type')
            audience5 = SubElement(comment5,'audience')
            full_comment=""
            #Concatinate comments
            for comment in nkcomments_ls:
                full_comment = full_comment+comment+'.'
            if printed == False:
                #print("Inserting comments for UID:",uid,full_comment)
                printed = True
            text5.text = full_comment
            type5.text = 'Comment'
            audience5.text = 'Official' 
    print('\n')

def InsertAllNKComments(t,dirfilels,uidmapping):
    (uid340set,uiddict340to500) = Create340to500UIDMapping(uidmapping)
    not_found_uid_ls=[]
    start_year=crfxmlconstants.lulu_start_year
    for file in dirfilels:
        f=open(file)
        print("Reading file",file)
        if os.path.basename(file).startswith('CKP'):
            start_year=crfxmlconstants.kp_start_year
        else:
            start_year=crfxmlconstants.lulu_start_year
        #datals = f.readlines()
        #datals = [x.strip('\n') for x in datals]
        #Split comments using ';' separator
        print("Start year",start_year)
        datals = [x.rpartition('#')[2].split(';') for x in f.readlines() if x.count('#') != 1]
        f.close()
        #datals = [x.split(';') for x in datals]
        counter=1
        for  nkcomments_ls in datals:
            if len(nkcomments_ls) == 0:
                print("Found empty line")
            else:
                #The first string in the list is the uid
                uid = nkcomments_ls.pop(0)
                #print(nkcomments_ls)
                #The old reporter wrapped uid in {}, the new one does not
                uid_new = uid.strip('{}')
                #Some UIDs have changed from CRFReporter version 3.4.0 to 5.0.0
                uid_changed = MapUID340to500(uid_new,uid340set,uiddict340to500)
                if uid_changed != uid_new:
                    print("UID changed:",uid_new,"-->",uid_changed)
                    uid_new = uid_changed
                InsertNKComment(uid_new,t,nkcomments_ls,counter,not_found_uid_ls,start_year)
                counter = counter+1
#---------------------------------The main program begins--------------------------------------------------
if __name__ == "__main__":
    #Command line generator
    parser = OP()
    parser.add_option("-c","--csv",dest="f1",help="Read GHG inventory Notation Key comment files")
    parser.add_option("-p","--pxml",dest="f2",help="Read CRFReporter Party Profile xml file")
    parser.add_option("-x","--xml",dest="f3",help="Write new Party profile populated with Notation Key comments")
    parser.add_option("-m","--map",dest="f4",help="CRFReporter 3.0.0 --> 5.0.0 UID mapping file")
    (options,args) = parser.parse_args()
 
    if options.f1 is None:
        print("No input Notation Key files")
        quit()
    if options.f2 is None:
        print("No input Party Profile xml file")
        quit()
    if options.f3 is None:
        print("No output Party Profile xml file")
        quit()
    if options.f4 is None:
        print("No output Party Profile xml file")
        quit()

    print("Inserting Notation key comments.")    
    #List the inventory files to be imported 
    dirfilels = glob.glob(options.f1)
    print("Parsing  Party Profile xml from:",options.f2)
    t=ET()
    t.parse(options.f2)
    print("Creating UID mapping from", options.f4)
    InsertAllNKComments(t,dirfilels,options.f4)
    print("Pretty printing xml to human readable form")
    PrettyPrint(t.getroot(),0,"   ")
    print("Writing xml file to",options.f3)
    t.write(options.f3)
